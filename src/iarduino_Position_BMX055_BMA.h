											//	СИМВОЛ g В НАСТОЯЩЕМ ФАЙЛЕ ОЗНАЧАЕТ - УСКОРЕНИЕ СВОБОДНОГО ПАДЕНИЯ! g = 9.81 м/с²
//	Акселерометр (G-сенсор)					//	Это датчик измеряющий кажущееся угловое ускорение, которое является геометрической разницей между истинным угловым ускорением и ускорением силы гравитации (g) которая всегда направлена к земле.
											//	Если акселерометр неподвижен (истинное ускорение отсутствует), его оси XY паралельны земле, а ось Z направлена вверх, то ...
											//	проекция кажущегося ускорения на ось Z = 0 - -g = g. Где 0 - истинное ускорение, -g сила гравитации направленная в сторону противоположную оси Z (значит взята с отрицательным знаком).
											//	Так как вектор g всегда направлен к земле, то в неподвижном состоянии датчик определяет угол наклона устройства относительно поверхности Земли.
											//	Эти данные можно использовать, например, для поворота изображения на экране (альбомное / ландшафтное).
											//
#ifndef iarduino_Position_BMX055_BMA_h		//	Функции работы с акселерометром модуля BMX055
#define iarduino_Position_BMX055_BMA_h		//
//	КОНСТАНТЫ АКСЕЛЕРОМЕТРА					//
#define	BMA						10			//	Константа используемая в качестве аргумента при объявлении объекта для работы с акселерометром
#define	BMA_ERR_ID				11			//	Ошибка возвращаемая функцией test(): датчик не найден
#define	BMA_ERR_ST				12			//	Ошибка возвращаемая функцией test(): выявлены неисправности при самотестировании
#define	BMA_M_S					13			//	Аргумент функции read()          указывающий выводить данные в м/с²
#define	BMA_G					14			//	Аргумент функции read()          указывающий выводить данные в количестве g
#define	BMA_DEG					15			//	Аргумент функции read()          указывающий выводить данные в градусах   (отклонение по осям XY относительно поверхности Земли)
#define	BMA_RAD					16			//	Аргумент функции read()          указывающий выводить данные в радианах   (отклонение по осям XY относительно поверхности Земли)
#define	BMA_8Hz					17			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 7.81  Гц, интервал обновлений данных  64 мс).
#define	BMA_16Hz				18			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 15.63 Гц, интервал обновлений данных  32 мс).
#define	BMA_31Hz				19			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 31.25 Гц, интервал обновлений данных  16 мс).
#define	BMA_63Hz				20			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 62.5  Гц, интервал обновлений данных   8 мс).
#define	BMA_125Hz				21			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 125   Гц, интервал обновлений данных   4 мс).
#define	BMA_250Hz				22			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 250   Гц, интервал обновлений данных   2 мс).
#define	BMA_500Hz				23			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 500   Гц, интервал обновлений данных   1 мс).
#define	BMA_1000Hz				24			//	Аргумент функции setBandwidths() указывающий полосу пропускания в Hz - Гц (полоса пропускания 1000  Гц, интервал обновлений данных 0.5 мс).
#define	BMA_2G					25			//	Аргумент функции setScale()      указывающий диапазон измерений в G  - g. (диапазон измерений ±2g)
#define	BMA_4G					26			//	Аргумент функции setScale()      указывающий диапазон измерений в G  - g. (диапазон измерений ±4g)
#define BMA_8G					27			//	Аргумент функции setScale()      указывающий диапазон измерений в G  - g. (диапазон измерений ±8g)
#define BMA_16G					28			//	Аргумент функции setScale()      указывающий диапазон измерений в G  - g. (диапазон измерений ±16g)
//	АДРЕС И ID ЧИПА:						//
#define	BMA_ADDRES				0x19		//	Адрес датчика на шине I2C
#define	BMA_ID					0xFA		//	ID датчика
//	РЕГИСТРЫ ЧИПА:							//											|	бит7	|	бит6	|	бит5	|	бит4	|	бит3	|	бит2	|	бит1	|	бит0	|при вкл|	Комментарий
#define	REG_BMA_CHIPID			0x00		//	ID чипа									|											ID<7:0>												| 0xFA	|	ID<7:0>		- значение регистра должно быть равно 0xFA (константа BMA_ID)
#define REG_BMA_X_LSB			0x02		//	Данные углового ускорения по оси X		|					x_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_x	| 0x00	|	x_lsb<3 :0> - младшие биты данных оси X, new_data_x - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_X_MSB			0x03		//	Данные углового ускорения по оси X		|					x_msb<11:4>																	| 0x00	|	x_msb<11:4> - старшие биты данных оси X
#define REG_BMA_Y_LSB			0x04		//	Данные углового ускорения по оси Y		|					y_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_y	| 0x00	|	y_lsb<3 :0> - младшие биты данных оси Y, new_data_y - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_Y_MSB			0x05		//	Данные углового ускорения по оси Y		|					y_msb<11:4>																	| 0x00	|	y_msb<11:4> - старшие биты данных оси Y
#define REG_BMA_Z_LSB			0x06		//	Данные углового ускорения по оси Z		|					z_lsb<3:0>					| -	- -	- -	- -	- -	- -	- -	- -	- -	|new_data_z	| 0x00	|	z_lsb<3 :0> - младшие биты данных оси Z, new_data_z - флаг указывающий на то что данные были обновлены после последнего чтения
#define REG_BMA_Z_MSB			0x07		//	Данные углового ускорения по оси Z		|					z_msb<11:4>																	| 0x00	|	z_msb<11:4> - старшие биты данных оси Z
#define REG_BMA_TEMP			0x08		//	Данные температуры чипа	в °C			|											temp<7:0>											| 0x00	|	temp<7:0>	- число в формате дополнения до двух с шагом 0.5°С и сдвигом на 23°С вниз. Для получения реальной тепературы нужно данные этого регистра умножить на шаг (0.5°С) и сложить с 23°C. Значение 0x00 соответствует температуре 23°C, значение 0x40 (64) соответствует температуре 55°C, значение 0xC0 (-64) соответствует температуре -9°C.
#define REG_BMA_INT_ST_0		0x09		//	Флаги состояния прерываний				|	flat	|  orient	|   s_tap	|   d_tap	|slo_not_mot|	slope	|	high	|	low		| 0x00	|	flat - датчик ускоряется в направлении одной из осей, orient - смена ориентации ускорения (x/y/z), s_tap - одиночное касание, d_tap - двойное касание, slo_not_mot - медленное движение или неподвижность, slope - наклон, high - высокое ускорение, low - низкое ускорение
#define REG_BMA_INT_ST_1		0x0A		//	Флаги состояния прерываний				|	data	|  fifo_wm	| fifo_full	| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	data - готовы новые данные, fifo_wm - буфер заполнен до уровня watermark, fifo_full - буфер полностью заполнен
#define REG_BMA_INT_ST_2		0x0B		//	Флаги состояния прерываний				|  tap_sign	|tap_first_z|tap_first_y|tap_first_x|slope_sign	|slopeFirstZ|slopeFirstY|slopeFirstX| 0x00	|	tap_sign - знак (направление) одиночного/двойного касания, tap_first_z - одиночное/двойное касание по оси Z, tap_first_y - одиночное/двойное касание по оси Y, tap_first_x - одиночное/двойное касание по оси X, slope_sign - знак (направление) наклона, slopeFirstZ - наклон по оси Z, slopeFirstY - наклон по оси Y, slopeFirstX - наклон по оси X
#define REG_BMA_INT_ST_3		0x0C		//	Флаги состояния прерываний				|	flat	|			 orient<2:0>			| high_sign	| highFirstZ| highFirstY| highFirstX| 0x00	|	flat - датчик ускоряется в направлении одной из осей, orient[2] - ориентация ускорения по оси Z («0» вверх, «1» вниз), orient<1:0> - ориентация ускорения по осям XY («00» вертикально вперед; «01» вертикально назаж; «10» горизонтально влево; «11» горизонтально вправо), high_sign знак (направление) высокого ускорения, highFirstZ - высокое ускорение по оси Z, highFirstY - высокое ускорение по оси Y, highFirstX - высокое ускорение по оси X
#define REG_BMA_FIFO_ST			0x0E		//	Статус буфера FIFO						|  overrun	|						fifo_frame_counter<6:0>										| 0x00	|	overrun - произошло переполнение буфера FIFO, fifo_frame_counter<6:0> - размер буфера FIFO (количество кадров хранимых в буфере)
#define REG_BMA_RANGE			0x0F		//	Диапазон измеряемого углового ускорения	| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|					range<3:0>					| 0xFF	|	range<3:0> - диапазон измеряемого углового ускорения: «0011» ±2g; «0101» ±4g; «1000» ±8g; «1100» ±16g
#define REG_BMA_BW				0x10		//	Полоса пропускания (Bandwidths)			| -	- -	- -	- -	- -	- -	- -	- -	- -	|							bw<4:0>							| 0x0F	|	bw<4:0> - полоса пропускания фильтрованных данных: «00xxx» 7.81 Гц; «01000» 7.81 Гц; «01001» 15.63 Гц; «01010» 31.25 Гц; «01011» 62.5 Гц; «01100» 125 Гц; «01101» 250 Гц; «01110» 500 Гц; «01111» 1000 Гц; «1xxxx» 1000 Гц
#define REG_BMA_LPW				0x11		//	Выбор основных режимов питания			|  suspend	|lowpower_en|deep_suspend|				sleep_dur<3:0>					| -	- -	- -	| 0x00	|	suspend - спящий режим, lowpower_en - режим пониженного энергосбережения, deep_suspend - режим глубокой приостановки. Можно установить только один из флагов suspend, lowpower_en и deep_suspend, а сброс всех трёх флагов в 0 установит нормальный режим. sleep_dur<3:0> - продолжительность фазы ожидания в режиме LOW_POWER (пониженного энергопотребления): «0000»...«0101» 0,5мс; «0110» 1мс; «0111» 2мс; «1000» 4мс; «1001» 6мс; «1010» 10мс; «1011» 25мс; «1100» 50мс; «1101» 100мс; «1110» 500мс; «1111» 1с.
#define REG_BMA_LOW_POWER		0x12		//	Конфигур. низкого энергопотребл.		| -	- -	- -	| lowpower	| sleeptimer| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	
#define REG_BMA_D_HBW			0x13		//	Выбор типа данных и их затенение		|dataHigh_bw| shadow_dis| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| 0x00	|	dataHigh_bw: «1» получение нефильтрованных данных; «0» получение фильтрованных данных, shadow_dis: «1» отключить / «0» включить механизм затенения регистров вывода данных углового ускорения. (затенение обеспечивает целостность данных, блокируя запись новых данных в старшие биты (MSB) если началось чтение младших битов (LSB), до тех пор пока не будут прочитаны старшие биты (MSB) данных углового ускорения).
#define REG_BMA_RESET			0x14		//	Программная перезагрузка				|											softreset<7:0>										| 0x00	|	Запись значения 0xB6 приведёт к перезагрузке и сбросу регистров.
#define REG_BMA_INT_EN_0		0x16		//	Флаги разрешения прерываний				|  flat_en	| orient_en	| s_tap_en	| d_tap_en	| -	- -	- -	| slope_en_z| slope_en_y| slope_en_x| 0x00	|	flat_en - разрешает прерывание отслеживающее ускорение датчика в направлении одной из осей, orient_en - разрешает прерывания по смене ориентации ускорения, s_tap_en - разрешает прерывание по одиночному касанию, d_tap_en - разрешает прерывание по двойному касанию, slope_en_z - разрешает прерывание фиксирующее наклон по оси z, slope_en_y - разрешает прерывание фиксирующее наклон по оси y, slope_en_x - разрешает прерывание фиксирующее наклон по оси x
#define REG_BMA_INT_EN_1		0x17		//	Флаги разрешения прерываний				| -	- -	- -	|  f_wm_en	| f_full_en	|  data_en	|  low_en	| high_en_z	| high_en_y	| high_en_x	| 0x00	|	f_wm_en - разрешает прерывание по заполнению буфера fifo до уровня (watermark), f_full_en - разрешает прерывание по полному заполнению буфера fifo, data_en - разрешает прерывание по поступлению новых данных, low_en - разрешает прерывание фиксирующее низкое ускорение, high_en_z - разрешает прерывание фиксирующее высокое ускорение по оси z, high_en_y - разрешает прерывание фиксирующее высокое ускорение по оси y, high_en_x - разрешает прерывание фиксирующее высокое ускорение по оси x
#define REG_BMA_INT_EN_2		0x18		//	Флаги разрешения прерываний				| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|sloNoMotSel|sloNoMotEnZ|sloNoMotEnY|sloNoMotEnX| 0x00	|	sloNoMotSel - выбор режима работы прерывания фиксирующего медленное движение или неподвижность («0» медленное движение; «1» неподвижность), sloNoMotEnZ - разрешает прерывание фиксирующее медленное движение или неподвижность по оси z, sloNoMotEnY - разрешает прерывание фиксирующее медленное движение или неподвижность по оси y, sloNoMotEnX - разрешает прерывание фиксирующее медленное движение или неподвижность по оси x
#define REG_BMA_INT_MAP_0		0x19		//	Флаги направляющие прерывания на INT1	| int1_flat	|int1_orient| int1_s_tap| int1_d_tap|int1SloNoMot|int1_slope| int1_high	| int1_low	| 0x00	|	int1_flat - направить прерывание по ускорению датчика в направлении одной из осей на вывод INT1, int1_orient - направить прерывание по смене ориентации ускорения на вывод INT1, int1_s_tap - направить прерывание по одиночному касанию на вывод INT1, int1_d_tap - направить прерывание по двойному касанию на вывод INT1, int1SloNoMot - направить прерывание по медленному движению или неподвижности на вывод INT1, int1_slope - направить прерывание по наклону на вывод INT1, int1_high - направить прерывание по высокому ускорению на вывод INT1, int1_low - направить прерывание по низкому ускорению на вывод INT1
#define REG_BMA_INT_MAP_1		0x1A		//	Флаги направл-е прерывания на INT1,INT2	| int2_data	|int2_f_wm	|int2_f_full| -	- -	- -	| -	- -	- -	|int1_f_full| int1_f_wm	| int1_data	| 0x00	|	int2_data - направить прерывание по готовности новых данных на вывод INT2, int2_f_wm - направить прерывание по заполнению буфера fifo до уровня (watermark) на вывод INT2, int2_f_full - направить прерывание по переполнению буфера fifo на вывод INT2, int1_f_full - направить прерывание по переполнению буфера fifo на вывод INT1, int1_f_wm - направить прерывание по заполнению буфера fifo до уровня (watermark) на вывод INT1, int1_data - направить прерывание по готовности новых данных на вывод INT1
#define REG_BMA_INT_MAP_2		0x1B		//	Флаги направляющие прерывания на INT2	| int2_flat	|int2_orient| int2_s_tap| int2_d_tap|int2SloNoMot|int2_slope| int2_high	| int2_low	| 0x00	|	int2_flat - направить прерывание по ускорению датчика в направлении одной из осей на вывод INT2, int2_orient - направить прерывание по смене ориентации ускорения на вывод INT2, int2_s_tap - направить прерывание по одиночному касанию на вывод INT2, int2_d_tap - направить прерывание по двойному касанию на вывод INT2, int2SloNoMot - направить прерывание по медленному движению или неподвижности на вывод INT2, int2_slope - направить прерывание по наклону на вывод INT2, int2_high - направить прерывание по высокому ускорению на вывод INT2, int2_low - направить прерывание по низкому ускорению на вывод INT2
#define REG_BMA_INT_SRC			0x1E		//	Тип данных используемых для прерываний	| -	- -	- -	- -	- -	- -	| src_data	| src_tap	|srcSloNoMot| src_slope	| src_high	|  src_low	| 0x00	|	Источником данных для соответствующих прерываний будут: «0» фильтрованные данные; «1» нефильтрованные данные
#define REG_BMA_INT_OUT_CTRL	0x20		//	Выбор поведения выводов INT1 и INT2		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|  int2_od	|  int2_lvl	|  int1_od	| int1_lvl	| 0x05	|	int2_od - выбор типа схемы для вывода INT2 («0» комплиментарная (push-pull); «1» открытый сток), int2_lvl - активный уровень на выводе INT2, int1_od - выбор типа схемы для вывода INT1 («0» комплиментарная (push-pull); «1» открытый сток), int1_lvl - активный уровень на выводе INT1
#define REG_BMA_INT_RST_LATCH	0x21		//	Выбор режима и сброс прерываний			| reset_int	| -	- -	- -	- -	- -	- -	- -	- -	- -	|					latch_int<3:0>				| 0x00	|	reset_int - установка в «1» приведёт к сбросу активных прерываний, latch_int<3:0> - определяет режим прерываний фиксированный, не фиксированный, или временный.
#define REG_BMA_INT_0			0x22		//	Значения для прерывания низк. ускорения	|											low_dur<7:0>										| 0x09	|	low_dur<7:0> - время задержки для прерывания фиксирующего низкое ускорение = (low_dur<7:0> + 1) * 2мс. Прерывание сработает если низкое ускорение фиксируется дольше времени зарержки. Из приведённой формулы получается что время задержки можно установить от 2 до 512 мс., значение по умолчанию 20 мс.
#define REG_BMA_INT_1			0x23		//	Значения для прерывания низк. ускорения	|											low_th<7:0>											| 0x30	|	low_th<7:0> - порог срабатывания для прерывания фиксирующего низкое ускорение = low_th<7:0> * 7.81мg. Прерывание сработает если фиксируемое ускорение ниже указанного порога. Из приведённой формулы получается что порог срабатывания можно установить от 0 до 1,992 g., значение по умолчанию 375 g.
#define REG_BMA_INT_2			0x24		//	Значения для низк. и высок. ускорения	|		high_hy<1:0>	| -	- -	- -	- -	- -	- -	- -	- -	- -	| low_mode	|		low_hy<1:0>		| 0x81	|	low_mode - режим работы прерывания низкого ускорения: «0» для прерывания учитываются данные каждой оси по отдельности; «1» для прерывания учитывается сумма всех осей, high_hy<1:0> - гистерезис прерывания фиксирующего высокое ускорение = high_hy<1:0> * 62.5мg * (диапазон измеряемого ускорения range<3:0> в g), low_hy<1:0> - гистерезис прерывания фиксирующего низкое ускорение = low_hy<1:0> * 125мg (независимо от диапазона измеряемого ускорения range<3:0>),
#define REG_BMA_INT_3			0x25		//	Значения для прерывания высок. ускорения|											high_dur<7:0>										| 0x0F	|	high_dur<7:0> - время задержки для прерывания фиксирующего высокое ускорение = (high_dur<7:0> + 1) * 2мс. Прерывание сработает если высокое ускорение фиксируется дольше времени зарержки. Из приведённой формулы получается что время задержки можно установить от 2 до 512 мс., значение по умолчанию 32 мс.
#define REG_BMA_INT_4			0x26		//	Значения для прерывания высок. ускорения|											high_th<7:0>										| 0xC0	|	high_th<7:0> - порог срабатывания для прерывания фиксирующего высокое ускорение = high_th<7:0> * 3.905мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемое ускорение выше указанного порога.
#define REG_BMA_INT_5			0x27		//	Значения для прерываний	наклона и ...	|							slo_no_mot_dur<5:0>							|	slope_dur<1:0>		| 0x00	|	slope_dur<1:0> - время задержки для прерывания фиксирующего наклон = slope_dur <1:0> + 1мс, slo_no_mot_dur<5:0> - зависит от бита sloNoMotSel: если sloNoMotSel=«0» то slo_no_mot_dur<1:0> (два бита!) должны быть выше порога срабатывания (slo_no_mot_th<7:0>) для прерывания фиксирующего медленное движение; если sloNoMotSel=«1» то slo_no_mot_dur<5:0> определяет время срабатывания для прерывания фиксирующего отсутствие движения (если slo_no_mot_dur<5:4>=«00» то время = slo_no_mot_dur<3:0> + 1мс, если slo_no_mot_dur<5:4>=«b01» то время = slo_no_mot_dur<3:0> * 4 + 20мс, если slo_no_mot_dur<5>=«1» то время = slo_no_mot_dur<4:0> * 8 + 88мс., 
#define REG_BMA_INT_6			0x28		//	Значения для прерывания наклона			|											slope_th<7:0>										| 0x14	|	slope_th<7:0> - порог срабатывания для прерывания фиксирующего наклон = slope_th<7:0> * 1.955 мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемый наклон выше указанного порога.
#define REG_BMA_INT_7			0x29		//	Значения для прерывания медл. движения	|										slo_no_mot_th<7:0>										| 0x14	|	slo_no_mot_th<7:0> - порог срабатывания для прерывания медленного движения = slo_no_mot_th<7:0> * 1.955 мg * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемое движение ниже указанного порога.
#define REG_BMA_INT_8			0x2A		//	Значения для одиночного/двойного касания| tap_quiet	| tap_shock	| -	- -	- -	- -	- -	- -	- -	- -	- -	|			tap_dur<2:0>			| 0x04	|	tap_quiet - длительность слабого однократного касания: «0» 30мс; «1» 20мс, tap_shock - длительность сильного однократного касания: «0» 50мс; «1» 70мс, tap_dur<2:0> - время задержки между двойным касанием = «000b» 50мс; «001b» 100мс; «010b» 150мс; «011b» 200мс; «100b» 250мс; «101b» 375мс; «110b» 500мс; «111b» 700мс.
#define REG_BMA_INT_9			0x2B		//	Значения для одиночного/двойного касания|	tap_samp<1:0>		| -	- -	- -	|						tap_th<4:0>							| 0x0A	|	tap_samp<1:0> - количество выборок данных для определения двойного/одиночного касания в режиме (lowpower) пониженного энергопотребления: «00b» 2 выборки; «01» 4 выборки; «10» 8 выборок; «11» 16 выборок, tap_th<4:0> - порог срабатывания для прерывания фиксирующего двойное/одиночное касание = tap_th<3:0> * 31.25 * (диапазон измеряемого ускорения: range<3:0> в g = ±2;±4;±8;±16), результат в мg. Прерывание сработает если фиксируемые касания выше указанного порога.
#define REG_BMA_INT_A			0x2C		//	Значения для прерывания ориентации		| -	- -	- -	|			orient_hyst<2:0>		|  orient_blocking<1:0>	|	orient_mode<1:0>	| 0x18	|	
#define REG_BMA_INT_B			0x2D		//	Значения для прерывания ориентации		| -	- -	- -	|orient_ud_en|							orient_theta<5:0>							| 0x48	|	
#define REG_BMA_INT_C			0x2E		//	Значения для прерывания в одной плоск.	| -	- -	- -	- -	- -	- -	|							flat_theta<5:0>								| 0x08	|	
#define REG_BMA_INT_D			0x2F		//	Значения для прерывания в одной плоск.	| -	- -	- -	- -	- -	- -	|  flat_hold_time<1:0>	| -	- -	- -	|			flat_hy[2:0]			| 0x11	|	
#define REG_BMA_FIFO_CONFIG_0	0x30		//	Уровень watermark для буфера fifo		| -	- -	- -	- -	- -	- -	|			fifo_water_mark_level_trigger_retain<5:0>					| 0x00	|	fifo_water_mark_level_trigger_retain<5:0> - уровень watermark для буфера FIFO. Как только буфер заполнится до этого уровня - сработает прерывание fifo_wm если оно разрешено флагом f_wm_en
#define REG_BMA_PMU_SELF_TEST	0x32		//	Настройка и запуск самотестирования		| -	- -	- -	- -	- -	- -	- -	- -	- -	|s_test_amp	| -	- -	- -	|s_test_sign|  self_test_axis<1:0>	| 0x00	|	s_test_amp - флаг выбора амплитуды самотестирования (в библиотеке используется высокая амплитуда): «1» высокая; «0» низкая, s_test_sign - флаг выбора знака (направления прилагаемой электростатической силы) самотестирования: «1» положительный; «0» отрецательный, self_test_axis<1:0> - выбор оси для самотестирования: «00» нет (самотестирование отключено); «01» ось X; «10» ось Y; «11» ось Z; после выбора оси начнётся самотестирование на что датчику требуется не менее 50мс.
#define REG_BMA_TRIM_NVM_CTRL	0x33		//	Настройка энергонезависимой памяти NVM	|				nvm_remain<3:0>					| nvm_load	|  nvm_rdy	| nvm_trig	| nvm_mode	| 0xF0	|	nvm_remain<3:0> - количество оставшихся циклов записи в NVM (многократно программируемую энергонезависимую память), nvm_load - флаг разрешающий обновление всех конфигурационных регистров из NVM памяти, nvm_rdy - флаг состояния готовности памяти NVM у записи: «0» выполняется запись (обновление) NVM; «1» память NVM готова принять новые тданные для записи, nvm_trig - флаг запускающий опреацию записи в NVM: «1» запуск; «0» нет, nvm_mode - флаг разблокировки записи в NVM: «1» запись разрешена (разблокирована); «0» запись запрещена (заблокирована).
#define REG_BMA_BGW_SPI3_WDT	0x34		//	Настройки для цифровых интерфейсов		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| i2c_wdt_en|i2c_wdt_sel|	spi3	| 0x00	|	i2c_wdt_en - флаг активации сторожевого таймера WDT на выводе SDA для шины I2C: «1» активен; «0» отключён, i2c_wdt_sel - выбор периода ожидания для сторожевого таймера на шине I2C: «0» 1 мс; «1» 50 мс, spi3 - флаг выбора 3-проводного режима шины SPI: «1» 3-проводной режим; «0» 4-проводный режим.
#define REG_BMA_OFC_CTRL		0x36		//	Управлен. вычислением компенс. смещения	|offset_reset|	cal_trigger<1:0>	|  cal_rdy	| -	- -	- -	|  hp_z_en	|  hp_y_en	|  hp_x_en	| 0x10	|	offset_reset - флаг сброса значений регистров смещения: «1» сбросить регистры смещения (0x38 - 0x3A) в ноль; «0» хранить значения регистров смещения, cal_trigger<1:0> - выполнить быстрое вычисление компенсации смещения для: «01» оси X; «10» осиY; «11» оси Z; «00» не выполнять быстрое вычисление компенсации смещения; (быстрое вычисление компенсации смещения не должно вызываться при сброшенном флаге cal_rdy), cal_rdy - флаг указывающий о готовности чипа к новому быстрому вычислению компенсации смещения: «1» готов; «0» не готов, hp_z_en - флаг запускающий медленное вычисление компенсации смещения по оси Z: «1» запустить; «0» не запускать, hp_y_en - флаг запускающий медленное вычисление компенсации смещения по оси Y: «1» запустить; «0» не запускать, hp_x_en - флаг запускающий медленное вычисление компенсации смещения по оси X: «1» запустить; «0» не запускать.
#define REG_BMA_OFC_SETTING		0x37		//	Настройки вычисления компенс. смещения	| -	- -	- -	| offset_target_z<1:0>	| offset_target_y<1:0>	| offset_target_x<1:0>	|  cut_off	| 0x00	|	offset_target_z<1:0> - установить значение компенсации для оси Z в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., offset_target_y<1:0> - установить значение компенсации для оси Y в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., offset_target_x<1:0> - установить значение компенсации для оси X в: «00» 0g.; «01» +1g.; «10» -1g.; «11» 0g., cut_off - граничная частота фильтра для медленного вычисления компенсации смещения: «0» 1Гц; «1» 10Гц
#define REG_BMA_OFC_OFFSET_X	0x38		//	Значение компенсации смещения по оси X	|										offset_x<7:0>											| 0x00	|	offset_x<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси X. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_OFC_OFFSET_Y	0x39		//	Значение компенсации смещения по оси Y	|										offset_y<7:0>											| 0x00	|	offset_y<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси Y. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_OFC_OFFSET_Z	0x3A		//	Значение компенсации смещения по оси Z	|										offset_z<7:0>											| 0x00	|	offset_z<7:0> - значение компенсации смещения для данных углового ускорения считываемых по оси Z. Значение смещения добавляется к подученным фильтрованным и нефильтрованным данным ускорения; Значение смещения представляется в виде числа в коде дополнения двух от -128 (-1g) до +127 (+0,992g) и не зависит от выбранного диапазона измерений; Содержимое этого регистра может быть записано в NVM (от куда будет автоматически восстанавливается после каждого включения питания или программной перезагрузки), или может быть вычислено (быстрым или медленным способом) результат вычислений записывается в регистр автоматически по завершении вычислений, или записано пользователем.
#define REG_BMA_TRIM_GPO		0x3B		//	Регистр памяти NVM общего назначения	|											GP0<7:0>											| 0x00	|	GP0<7:0> - данные этого регистра могут быть записаны в NVM (многократно программируемую энергонезависимую память) и будут восстанавливаться из неё в этот регистр при каждом включении или программной перезагрузке. Регистр не несёт какой либо функциональности и может быть использован пользователем
#define REG_BMA_TRIM_GP1		0x3C		//	Регистр памяти NVM общего назначения	|											GP1<7:0>											| 0x00	|	GP1<7:0> - данные этого регистра могут быть записаны в NVM (многократно программируемую энергонезависимую память) и будут восстанавливаться из неё в этот регистр при каждом включении или программной перезагрузке. Регистр не несёт какой либо функциональности и может быть использован пользователем
#define REG_BMA_FIFO_CONFIG_1	0x3E		//	Настройки конфигурации буфера FIFO		|	fifo_mode<1:0>		| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	| fifo_data_select<1:0>	| 0x00	|	fifo_mode<1:0> - выбор режима работы буфера FIFO: «00» BYPASS (глубина буфера 1 кадр, старые данные стираются); «01» FIFO (сбор данных прекращается при полном заполнении буфера - 32 кадра); «10» STREAM (сбор данных продолжается при полном заполнении буфера, старые кадры стираются), fifo_data_select<1:0> - выбор данных для буфера FIFO: «00» собираются данные всех осей XYZ; «01» собираются данные только оси X; «10» собираются данные только оси Y; «11» собираются данные только оси Z. При записи данных в регистр FIFO_CONFIG_1, память FIFO буфера и флаг fifo-full очищается.
#define REG_BMA_FIFO_DATA		0x3F		//	Регистр чтения данных из буфера FIFO	|										fifo_data<7:0>											| 0x00	|	fifo_data<7:0> - байт для чтения данных из буфера FIFO. Данные буфера FIFO хранятся кадрами (объём буфера равен 32 кадра). Состав кадра зависит от значения битов fifo_data_select<1:0> регистра REG_BMA_FIFO_CONFIG_1: Если выбраны данные всех осей XYZ, то каждый кадр считывается побайтно в следующем порядке X-lsb, X-msb, Y-lsb, Y-msb, Z-lsb, Z-msb; Если выбраны данные только оси X, то каждый кадр считывается побайтно в следующем порядке X-lsb, X-msb; Если выбраны данные только оси Y или только оси Z, то каждый кадр считывается побайтно, как и для оси X. Если чтение буфера остановлено и кадр считан не полностью, то при следующей инициализации чтения в fifo_data<7:0> будет находиться пербый байт следующего кадра.

#include "iarduino_RTC_I2C.h"																									//	Подключаем файл iarduino_RTC_I2C.h - для работы с шиной I2C
																																//
class iarduino_Position_BMX055_BMA: public iarduino_Position_BMX055_BASE{														//
	public:																														//
	/**	функции доступные пользователю **/																						//
//		Инициализация датчика:																									//
		bool	begin(iarduino_I2C_Select* ptrI2C, bool setZero, float*ptrX,float*ptrY,float*ptrZ,float*ptrT, float*ptrQ1,float*ptrQ2,float*ptrQ3,float*ptrQ4){ // Аргументы: ptrI2C - указатель на объект работы с шиной I2C, setZero - флаг указывающий о необходимости установить текущие показания в 0, указатели на переменные выводимых данных)
					selI2C = ptrI2C;																							//	Присваиваем указателю selI2C адрес из указателя ptrI2C
					axisX  = ptrX;																								//	Присваиваем указателю axisX  адрес из указателя ptrX который ссылается на переменную axisX класса iarduino_Position_BMX055 предназначенную для вывода данных по оси X
					axisY  = ptrY;																								//	Присваиваем указателю axisY  адрес из указателя ptrY который ссылается на переменную axisY класса iarduino_Position_BMX055 предназначенную для вывода данных по оси Y
					axisZ  = ptrZ;																								//	Присваиваем указателю axisZ  адрес из указателя ptrZ который ссылается на переменную axisZ класса iarduino_Position_BMX055 предназначенную для вывода данных по оси Z
					temp   = ptrT;																								//	Присваиваем указателю temp   адрес из указателя ptrT который ссылается на переменную temp  класса iarduino_Position_BMX055 предназначенную для вывода температуры
					if( selI2C->readByte(BMA_ADDRES, REG_BMA_CHIPID) != BMA_ID ){ return false; }								//	Возвращаем ошибку если содержимое регистра REG_BMA_CHIPID не совпало с реальным ID чипа указанным в константе BMA_ID
					selI2C->writeByte(BMA_ADDRES, REG_BMA_RESET, 0xB6);															//	Выполняем программную перезагрузку (записываем значение 0xB6 в регистр REG_BMA_RESET)
					delay(100);																									//	Ждём сброса регистров
					selI2C->writeByte(BMA_ADDRES, REG_BMA_LPW, 0x00);															//	Переводим акселеромерт в нормальный режим питания (сбрасываем флаги suspend, lowpower_en и deep_suspend)
					setScale(varRanges);																						//	Устанавливаем диапазон измерений акселерометра (указывая предел измеряемого углового ускорения)
					setBandwidths(varBandwidth);																				//	Устанавливаем пропускную способность акселерометра (указывая частоту обновления фильтрованных данных)
					selI2C->writeByte(BMA_ADDRES, REG_BMA_D_HBW, 0x00);															//	Указываем акселерометру, что требуется выводить отфильтрованные данные (dataHigh_bw=0) с механизмом их затенения во время чтения (shadow_dis=0). Затенение осначает что значение регистров данных не будет изменяться от начала и до конца пакетного чтения
					if( setZero ){ setFastOffset(BMA); }																		//	Выполняем быструю компенсацию смещения данных (значение всех осей сбросятся в ноль, если данные текущих уговвых ускорений были меньше ±1g.)
					return true;																								//
		}																														//
																																//
//		Самотестирование датчика:																								//
		uint8_t	test(void){																										//	Аргумент: отсутствует
					if( selI2C->readByte(BMA_ADDRES, REG_BMA_CHIPID) != BMA_ID ){ return BMA_ERR_ID; }							//	Возвращаем ошибку если содержимое регистра REG_BMA_CHIPID не совпало с реальным ID чипа указанным в константе BMA_ID
					uint8_t f = 0;																								//	Результат
					uint8_t	i = varRanges;    setScale(BMA_8G);																	//	Сохраняем установленный ранее диапазон измерения и устанавливаем диапазон 8g
					uint8_t	j = varBandwidth; setBandwidths(BMA_16Hz);															//	Сохраняем установленную ранее полосу пропускания и устанавливаем полосу пропускания 16Гц
					float   k[6];												delay( 50);										//	Объявляем массив для получения данных
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x11);	delay(500);	while(!read(true)){}; k[0]=*axisX;	//	Выполняем самотестирование оси X c приложением отрицательной электростатической силы к сердечнику датчика и записываем данные этой оси в k[0]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x12);	delay(500);	while(!read(true)){}; k[1]=*axisY;	//	Выполняем самотестирование оси Y c приложением отрицательной электростатической силы к сердечнику датчика и записываем данные этой оси в k[1]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x13);	delay(500);	while(!read(true)){}; k[2]=*axisZ;	//	Выполняем самотестирование оси Z c приложением отрицательной электростатической силы к сердечнику датчика и записываем данные этой оси в k[2]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x15);	delay(500);	while(!read(true)){}; k[3]=*axisX;	//	Выполняем самотестирование оси X c приложением положительной электростатической силы к сердечнику датчика и записываем данные этой оси в k[3]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x16);	delay(500);	while(!read(true)){}; k[4]=*axisY;	//	Выполняем самотестирование оси Y c приложением положительной электростатической силы к сердечнику датчика и записываем данные этой оси в k[4]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x17);	delay(500);	while(!read(true)){}; k[5]=*axisZ;	//	Выполняем самотестирование оси Z c приложением положительной электростатической силы к сердечнику датчика и записываем данные этой оси в k[5]
					selI2C->writeByte(BMA_ADDRES, REG_BMA_PMU_SELF_TEST, 0x00);	delay( 50);	while(!read(true)){}; 				//	Завершаем самотестирование
					k[0] = (k[0]>k[3])? k[0]-k[3] : k[3]-k[0];		if(k[0]<0.8){f=BMA_ERR_ST;}									//	Вычисляем разницу между полученными показаниями для оси X. Если разница меньше 0.8g, значит тест не пройден.
					k[1] = (k[1]>k[4])? k[1]-k[4] : k[4]-k[1];		if(k[1]<0.8){f=BMA_ERR_ST;}									//	Вычисляем разницу между полученными показаниями для оси Y. Если разница меньше 0.8g, значит тест не пройден.
					k[2] = (k[2]>k[5])? k[2]-k[5] : k[5]-k[2];		if(k[2]<0.4){f=BMA_ERR_ST;}									//	Вычисляем разницу между полученными показаниями для оси Z. Если разница меньше 0.4g, значит тест не пройден.
					setScale(i);																								//	Восстанавливаем установленный ранее диапазон измерения
					setBandwidths(j);																							//	Восстанавливаем установленную ранее полосу пропускания
					delay(100); return f;																						//	Ждём 100мс и выводим результат
		}																														//
																																//
//		Чтение данных из датчика:																								//
		bool	read(uint8_t thisMera){																							//	Аргумент: мера измерения читаемых данных (BMA_M_S / BMA_G / BMA_DEG / BMA_RAD)
					uint8_t i[7];																								//	Объявляем массив i размером 7 байт
					if( !selI2C->readBytes(BMA_ADDRES, REG_BMA_X_LSB, i, 7) ){ return false; }									//	Читаем 7 байт одним пакетом начиная с регистра REG_BMA_X_LSB в массив i
					if( i[0]&0x01 ){																							//	Если последний бит данных оси X равен «1» значит данные новые, то ...
					if( i[2]&0x01 ){																							//	Если последний бит данных оси Y равен «1» значит данные новые, то ...
					if( i[4]&0x01 ){																							//	Если последний бит данных оси Z равен «1» значит данные новые, то ...
					//	Получаем данные в количестве ускорений свободного падения:												//
						*axisX = float(int16_t((int16_t(i[1])<<8) | i[0])>>4) * varQuantum;										//	Получаем результирующее 12-битное значение из частей MSB (i[1]), LSB (i[0]), умножаем его на шаг квантования varQuantum
						*axisY = float(int16_t((int16_t(i[3])<<8) | i[2])>>4) * varQuantum;										//	Получаем результирующее 12-битное значение из частей MSB (i[3]), LSB (i[2]), умножаем его на шаг квантования varQuantum
						*axisZ = float(int16_t((int16_t(i[5])<<8) | i[4])>>4) * varQuantum;										//	Получаем результирующее 12-битное значение из частей MSB (i[5]), LSB (i[4]), умножаем его на шаг квантования varQuantum
						*temp  = float(int16_t( int16_t(i[6])<<8) >> 8) * 0.5 + 23.0;											//  Получаем результирующее 8-битное  знаковое значение из беззнакового   i[6] , умножаем его на шаг 0.5°С и складываем с постоянной составляющей 23°С
						switch(thisMera){																						//	В зависимости от установленной меры измерений
							default:	thisMera=BMA_M_S;																		//	По умолчанию значения возвращаются в м/с²
							case		BMA_M_S: *axisX*=9.81f; *axisY*=9.81f; *axisZ*=9.81f;	break;							//	Если данные требуется возвращать в м/с², то умножаем количество g на значение g
							case		BMA_G:													break;							//	Если данные требуется возвращать в g (количестве ускорений свободного падения), то они уже готовы.
							case		BMA_RAD:																				//	Если данные требуется возвращать в радианах
							case		BMA_DEG:																				//	Если данные требуется возвращать в градусах
										*axisX=atan(*axisX/sqrt(sq(*axisY)+sq(*axisZ)));										//	Угол в радианах для оси X = arctan( gX / √( gY² + gZ²) )
										*axisY=atan(*axisY/sqrt(sq(*axisZ)+sq(*axisX)));										//	Угол в радианах для оси Y = arctan( gY / √( gZ² + gX²) )
										*axisZ=atan(*axisZ/sqrt(sq(*axisX)+sq(*axisY)));										//	Угол в радианах для оси Z = arctan( gZ / √( gX² + gY²) )
										if( thisMera==BMA_DEG ){ *axisX*=180/PI; *axisY*=180/PI; *axisZ*=180/PI; }	break;		//	Преобразуем угол из радиан в градусы.
						}																										//
						return true;																							//
					}}}																											//
					return false;																								//	Сообщаем о ошибке (данные не обновлены).
		}																														//
																																//
//		Установка диапазона измерений:																							//
		void	setScale(uint8_t scale){																						//	Аргумент: предел измеряемого углового ускорения
					uint8_t i=0x03;																								//	Значение для записи в регистр REG_BMA_RANGE.
					switch (scale){																								//	Проверяем значение аргумента функции (максимальное детектируемое угловое ускорение)
						default:		scale=BMA_2G;																			//	Если значение некорректное, то меняем его на BMA_2G (значение по умолчанию).
						case BMA_2G:	varQuantum = 2.0 /2048.0; i=0x03; break;												//	Вся шкала 12 бит (±2048) равна ускорению ±2 g. Определяем шаг квантования (какому угловому ускорению равно значение «1» из регистра данных на выбранном диапазоне).
						case BMA_4G:	varQuantum = 4.0 /2048.0; i=0x05; break;												//	Вся шкала 12 бит (±2048) равна ускорению ±4 g. Определяем шаг квантования (какому угловому ускорению равно значение «1» из регистра данных на выбранном диапазоне).
						case BMA_8G:	varQuantum = 8.0 /2048.0; i=0x08; break;												//	Вся шкала 12 бит (±2048) равна ускорению ±8 g. Определяем шаг квантования (какому угловому ускорению равно значение «1» из регистра данных на выбранном диапазоне).
						case BMA_16G:	varQuantum = 16.0/2048.0; i=0x0C; break;												//	Вся шкала 12 бит (±2048) равна ускорению ±16g. Определяем шаг квантования (какому угловому ускорению равно значение «1» из регистра данных на выбранном диапазоне).
					}																											//
					varRanges=scale;																							//	Запоминаем выбранный диапазон измерений
					selI2C->writeByte(BMA_ADDRES, REG_BMA_RANGE, i);															//	Устанавливаем диапазон измерений акселерометра (последние 4 бита регистра REG_BMA_RANGE)
		}																														//
																																//
//		Установка полосы пропускания для фильтрованных данных:																	//
		void	setBandwidths(uint8_t bandwidths){																				//	Аргумент: полоса пропускания
					uint8_t i=0x08;																								//	Значение для записи в регистр REG_BMA_BW.
					switch (bandwidths){																						//	Проверяем значение аргумента функции (максимальное детектируемое угловое ускорение)
						default:			bandwidths=BMA_16Hz;																//	Если значение некорректное, то меняем его на BMA_16Hz (значение по умолчанию).
						case BMA_16Hz:		i=0x09; break;																		//	Для полосы пропускания   15.63 Гц, интервал обновлений данных  32 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_8Hz:		i=0x08; break;																		//	Для полосы пропускания    7.81 Гц (интервал обновлений данных  64 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_31Hz:		i=0x0A; break;																		//	Для полосы пропускания   31.25 Гц, интервал обновлений данных  16 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_63Hz:		i=0x0B; break;																		//	Для полосы пропускания   62.5  Гц, интервал обновлений данных   8 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_125Hz:		i=0x0C; break;																		//	Для полосы пропускания  125    Гц, интервал обновлений данных   4 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_250Hz:		i=0x0D; break;																		//	Для полосы пропускания  250    Гц, интервал обновлений данных   2 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_500Hz:		i=0x0E; break;																		//	Для полосы пропускания  500    Гц, интервал обновлений данных   1 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
						case BMA_1000Hz:	i=0x0F; break;																		//	Для полосы пропускания 1000    Гц, интервал обновлений данных 0.5 мс) нужно записать i в биты bw<4:0> регистра REG_BMA_BW.
					}																											//
					varBandwidth=bandwidths;																					//	Запоминаем выбранную полосу пропускания
					selI2C->writeByte(BMA_ADDRES, REG_BMA_BW, i);																//	Устанавливаем пропускную способность акселерометра (последние 4 бита регистра REG_BMA_BW).
		}																														//
																																//
//		Выполнение быстрой компенсации смещения данных:																			//
		void	setFastOffset(uint8_t offset){																					//	Аргумент: не имеет значения.
						uint8_t i;																								//
						selI2C->writeByte(BMA_ADDRES, REG_BMA_OFC_CTRL,    0x80);												//	Сбрасываем все значения регистров компенсаций смещения в 0 (установкой флага offset_reset)
						selI2C->writeByte(BMA_ADDRES, REG_BMA_OFC_SETTING, 0x20);												//	Устанавливаем значения компенсации смещения в X=0g, Y=0g, Z=+1g (offset_target_z=«01», offset_target_y=«00», offset_target_x=«00», cut_off=«0»)
						selI2C->writeByte(BMA_ADDRES, REG_BMA_OFC_CTRL,    0x20);												//	Вычисляем смещение для оси X (cal_trigger=«01» быстрое вычисление компенсации смешения)
				do{ i = selI2C->readByte (BMA_ADDRES, REG_BMA_OFC_CTRL         ); delay(10);} while (i&0x10==0);				//	Ждём завершения быстрой компенсации смещения (ждём пока установится флаг cal_rdy)
						selI2C->writeByte(BMA_ADDRES, REG_BMA_OFC_CTRL,    0x40);												//	Вычисляем смещение для оси Y (cal_trigger=«10» быстрое вычисление компенсации смешения)
				do{ i = selI2C->readByte (BMA_ADDRES, REG_BMA_OFC_CTRL         ); delay(10);} while (i&0x10==0);				//	Ждём завершения быстрой компенсации смещения (ждём пока установится флаг cal_rdy)
						selI2C->writeByte(BMA_ADDRES, REG_BMA_OFC_CTRL,    0x60);												//	Вычисляем смещение для оси Z (cal_trigger=«11» быстрое вычисление компенсации смешения)
				do{ i = selI2C->readByte (BMA_ADDRES, REG_BMA_OFC_CTRL         ); delay(10);} while (i&0x10==0);				//	Ждём завершения быстрой компенсации смещения (ждём пока установится флаг cal_rdy)
		}																														//
																																//
//		Функции не используемые акселерометром:																					//
		void	setFastOffset (float* offset){;}																				//	Установка массива компенсации смещения данных используется только для объекта BMM, но функцию объявить нужно, так как данный класс является производным и должен содержать все функции полиморфного класса
		void	getFastOffset (float* offset){;}																				//	Получение массива компенсации смещения данных используется только для объекта BMM, но функцию объявить нужно, так как данный класс является производным и должен содержать все функции полиморфного класса
		uint8_t	getFilter     (void         ){return 0;}																		//	Фильтр используется только для объекта BMX, но функцию объявить нужно, так как данный класс является производным и должен содержать все функции полиморфного класса
																																//
	private:																													//
	/**	Внутренние переменные **/																								//
		iarduino_I2C_Select *selI2C;																							//	Создаём указатель на объект работы с шиной I2C.
		uint8_t	varRanges =		BMA_2G;																							//	Определяем переменную для хранения полного диапазона измерений (какому угловому ускорению соответствует значение где все биты установлены в «1»)
		uint8_t	varBandwidth =	BMA_16Hz;																						//	Определяем переменную для хранения полосы пропускания фильтрованных данных
		float	varQuantum =	2.0/2048.0;																						//	Определяем переменную для хранения шага квантования (какому угловому ускорению равно значение «1» из регистра данных на выбранном диапазоне)
		float *	axisX;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси X
		float *	axisY;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси Y
		float *	axisZ;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси Z
		float *	temp;																											//	Объявляем указатель который будет ссылаться на переменную для вывода температуры
};																																//
																																//
#endif																															//