//	Магнитометр (тесламетр)					//	Это датчик измеряющий магнитную индукцию, он определяет положение устройства в пространстве отностиельно магнитных полюсов земли.
											//	Эти данные можно использовать, например, для определения северного полюса земли
											//
#ifndef iarduino_Position_BMX055_BMM_h		//	Функции работы с магнитометром модуля BMX055
#define iarduino_Position_BMX055_BMM_h		//
											//
#define	BMM						3			//	Константа используемая в качестве аргумента при объявлении объекта для работы с магнитометром
#define	BMM_ERR_ID				3			//	ошибка возвращаемая функцией test(): датчик не найден
#define	BMM_ERR_ST				6			//	ошибка возвращаемая функцией test(): выявлены неисправности при самотестировании
#define	BMM_MG					0			//	Аргумент функции read() указывающий выводить данные в миллигаусах
#define	BMM_MCT					1			//	Аргумент функции read() указывающий выводить данные в микротеслах
#define	BMM_10Hz				0b000		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания 10 Гц, скорость передачи данных 10 Гц)
#define	BMM_2Hz					0b001		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания  2 Гц, скорость передачи данных  2 Гц)
#define	BMM_6Hz					0b010		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания  6 Гц, скорость передачи данных  6 Гц)
#define	BMM_8Hz					0b011		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания  8 Гц, скорость передачи данных  8 Гц)
#define	BMM_15Hz				0b100		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания 15 Гц, скорость передачи данных 15 Гц)
#define	BMM_20Hz				0b101		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания 20 Гц, скорость передачи данных 20 Гц)
#define	BMM_25Hz				0b110		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания 25 Гц, скорость передачи данных 25 Гц)
#define	BMM_30Hz				0b111		//	Один из возможных вариантов полосы пропускания в Hz - Гц		(полоса пропускания 30 Гц, скорость передачи данных 30 Гц)
#define	BMM_LOW_PWR				0b00		//	Один из возможных вариантов предустановленных значений			(экономичный  - рекомендуемая полоса пропускания 10 Гц,  3 выборки для осей XY,  3 выборки для оси Z, шумы по осям X/Y/Z = 1.0/1.0/1.4 мкТл, среднее потребление тока 0.17 мА)
#define	BMM_REGULAR				0b01		//	Один из возможных вариантов предустановленных значений			(обычный      - рекомендуемая полоса пропускания 10 Гц,  9 выборок для осей XY, 15 выборок для оси Z, шумы по осям X/Y/Z = 0.6/0.6/0.6 мкТл, среднее потребление тока 0.50 мА)
#define	BMM_ENHANCED			0b10		//	Один из возможных вариантов предустановленных значений			(улучшенный   - рекомендуемая полоса пропускания 10 Гц, 15 выборок для осей XY, 27 выборок для оси Z, шумы по осям X/Y/Z = 0.5/0.5/0.5 мкТл, среднее потребление тока 0.80 мА)
#define	BMM_HIGH				0b11		//	Один из возможных вариантов предустановленных значений			(высокой точн.- рекомендуемая полоса пропускания 20 Гц, 47 выборок для осей XY, 83 выборки для оси Z, шумы по осям X/Y/Z = 0.3/0.3/0.3 мкТл, среднее потребление тока 4.90 мА)
//	АДРЕС И ID ЧИПА:						//
#define	BMM_ADDRES				0x13		//	Адрес датчика на шине I2C
#define	BMM_ID					0x32		//	ID датчика
//	РЕГИСТРЫ ЧИПА:							//											|	бит7	|	бит6	|	бит5	|	бит4	|	бит3	|	бит2	|	бит1	|	бит0	|при вкл|	Комментарий
#define	REG_BMM_CHIPID			0x40		//	ID чипа									|											ID<7:0>												| 0x32	|	ID<7:0>			- значение регистра должно быть равно 0x32 (константа BMM_ID). ID чипа может быть прочитан только в том случае, если установлен бит управления мощностью pwr_control (регистр 0x4B бит 0).
#define	REG_BMM_X_LSB			0x42		//	Данные магнитного поля по оси X			|						x_lsb<4:0>							| -	- -	- -	- -	- -	- -	|x_self_test| N/A	|	x_lsb<4:0>		- младшие биты данных оси X, x_self_test - флаг результата самотестирования для оси X.
#define	REG_BMM_X_MSB			0x43		//	Данные магнитного поля по оси X			|						x_msb<12:5>																| N/A	|	x_msb<12:5>		- старшие биты данных оси X.
#define	REG_BMM_Y_LSB			0x44		//	Данные магнитного поля по оси Y			|						y_lsb<4:0>							| -	- -	- -	- -	- -	- -	|y_self_test| N/A	|	y_lsb<4:0>		- младшие биты данных оси Y, y_self_test - флаг результата самотестирования для оси Y.
#define	REG_BMM_Y_MSB			0x45		//	Данные магнитного поля по оси Y			|						y_msb<12:5>																| N/A	|	y_msb<12:5>		- старшие биты данных оси Y.
#define	REG_BMM_Z_LSB			0x46		//	Данные магнитного поля по оси Z			|						y_lsb<6:0>													|z_self_test| N/A	|	z_lsb<6:0>		- младшие биты данных оси Z, z_self_test - флаг результата самотестирования для оси Z.
#define	REG_BMM_Z_MSB			0x47		//	Данные магнитного поля по оси Z			|						y_msb<14:7>																| N/A	|	z_msb<14:7>		- старшие биты данных оси Z.
#define	REG_BMM_TEMP_LSB		0x48		//	Данные сопротивления термодатчика		|										r_hall_lsb<5:0> 				| -	- -	- -	| data_ready| N/A	|	r_hall_lsb<5:0>	- младшие биты беззнакового значения сопротивления для измерения температуры датчика Холла, data_ready - флаг прерывания готовности данных (флаг устанавливается если данные магнитного поля и сопротивления обновлены, но еще ничего не прочитано).
#define	REG_BMM_TEMP_MSB		0x49		//	Данные сопротивления термодатчика		|										r_hall_msb<13:6> 										| N/A	|	r_hall_msb<13:6>- старшие биты беззнакового значения сопротивления для измерения температуры датчика Холла.
#define	REG_BMM_INT_STATUS		0x4A		//	Флаги состояния прерываний				|  overrun	| overflow	| high_int_z| high_int_y| high_int_x| low_int_z	| low_int_y	| low_int_x	| 0x00	|	overrun - флаг перерасхода данных сигнализирует что данные обновляются в то время как предыдущие еще не были прочитаны, overflow - флаг переполнения сигнализирует что данные по одной из осей вышли за предел диапазона измерений, high_int_zyx - флаги сигнализируют что данные по оси ZYX превысили значение высокопорогового прерывания, low_int_zyx - флаги сигнализируют что данные по оси ZYX опустились ниже значения низкопорогового прерывания.
#define	REG_BMM_CTRL_0			0x4B		//	Управление питанием и перезагрузка		|softreset 1| -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	- -	|	spi3	|softreset 0|pwr_control| 0x01	|	softreset<1:0> - установка в «11» приводит к программной перезагрузке, spi3 - флаг выбора 3-проводного режима шины SPI: «1» 3-проводной режим; «0» 4-проводный режим, pwr_control - бит управления мощьностью: «0» - режим приостановки (suspend); «1» - спящий режим (sleep); в активный режим (Normal) нормальный или Forced (принудительный) можно перейти только из спящего (sleep) режима установкой битов op_mode<1:0> следующего регистра.
#define	REG_BMM_CTRL_1			0x4C		//	Режимы работы, скорость и тестирование	|advanced_self_test<1:0>|			data_rate<2:0>			|	  op_mode<1:0>		| self_test	| 0x06	|	advanced_self_test<1:0> - подача тока на обмотку намотанную вогруг датчика Холла которая создаёт магнитное поле в 100 мкТ на оси Z для проведения расширенного самотестирования: «00» - отключено; «10» отрицательное поле; «11» положительное поле, data_rate<2:0> - скорость передачи данных (ODR): «000»-10Гц (по умолчанию); «001»-2Гц; «010»-6Гц; «011»-8Гц; «100»-15Гц; «101»-20Гц; «110»-25Гц; «111»-30Гц, op_mode<1:0> - режимы работы магнитометра: «00»-Normal (нормальный активный режим) данные читаются постоянно со скоростью data_rate (ODR); «01»-Forced (принудительный активный режим) после входа в указанный режим данные однократно читаются записываются в регистры данных и устройство само переходит в спящий режим; «11»-Sleep спящий режим, self_test - флаг запуска обычного самотестирования.
#define	REG_BMM_INT_EN_0		0X4D		//	Флаги разрешения прерываний				| overrun_en|overflow_en| h_int_z_en| h_int_y_en| h_int_x_en| l_int_z_en| l_int_y_en| l_int_x_en| 0x3F	|	overrun_en - флаг разрешает установку флага overrun по прерыванию перерасхода данных, overflow_en - флаг разрешает направить прерывание overflow (переполнение) на вывод int, h_int_zyx_en - флаги (активный уровень 0) разрешают использовать оси ZYX для высокопорогового прерывания, l_int_zyx_en - флаги (активный уровень 0) разрешают использовать оси ZYX для низкопорогового прерывания.
#define	REG_BMM_INT_EN_1		0x4E		//	Флаги разрешения прерываний				|pin_dtrd_en| pin_int_en| channel_z	| channel_y	| channel_x	| dr_polar	| int_latch	| int_polar	| 0x07	|	pin_dtrd_en - флаг разрешает работу вывода прерывания dtrd (data ready - готовность данных), pin_int_en - флаг разрашает работу вывода int, channel_zyx - флаги (активный уровень 0) разрешают измерения по осям ZYX (если отключить ось Z то отключится и измерение сопростивления r_hall) данные отключённой оси остаются в регистре данных, dr_polar - флаг определяет полярность активного логического уровня на выводе прерывания dtrd, int_latch - флаг захвата прерываний: «1» - прерывания исчезают только после чтения регистра 0x4A; «0» - прерывания исчезают при исчезновении обстоятельств их вызвавших, int_polar - флаг определяет полярность активного логического уровня на выводе прерывания int.
#define	REG_BMM_LOW_TH			0x4F		//	Граница низкопорогового  прерывания		|										low_threshold<7:0>										| 0x00	|	low_threshold<7:0> - граничное значение для низкопорогового прерывания
#define	REG_BMM_HIGH_TH			0x50		//	Граница высокопорогового прерывания		|										high_threshold<7:0>										| 0x00	|	high_threshold<7:0> - граничное значение для высокопорогового прерывания
#define	REG_BMM_REP_XY			0x51		//	Количество выборок для осей XY			|											rep_xy<7:0>											| 0x00	|	rep_xy<7:0>    - беззнаковое количество выборок для осей x/y. Количество выборок = 1 + 2 * значение регистра
#define	REG_BMM_REP_Z			0x52		//	Количество выборок для оси  Z 			|											rep_z<7:0>											| 0x00	|	rep_z<7:0>     - беззнаковое количество выборок для оси z. Количество выборок = 1 + значение регистра
#define REG_BMM_DIG_X1			0x5D		//	Значения корректировки					|											dig_x1<7:0>											| конст	|	dig_x1<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Y1			0x5E		//	Значения корректировки					|											dig_y1<7:0>											| конст	|	dig_y1<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z4_LSB		0x62		//	Значения корректировки					|											dig_z4<7:0>											| конст	|	dig_z4<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z4_MSB		0x63		//	Значения корректировки					|											dig_z4<15:8>										| конст	|	dig_z4<15:8>   - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_X2			0x64		//	Значения корректировки					|											dig_x2<7:0>											| конст	|	dig_x2<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Y2			0x65		//	Значения корректировки					|											dig_y2<7:0>											| конст	|	dig_y2<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z2_LSB		0x68		//	Значения корректировки					|											dig_z2<7:0>											| конст	|	dig_z2<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z2_MSB		0x69		//	Значения корректировки					|											dig_z2<15:8>										| конст	|	dig_z2<15:8>   - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z1_LSB		0x6A		//	Значения корректировки					|											dig_z1<7:0>											| конст	|	dig_z1<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z1_MSB		0x6B		//	Значения корректировки					|											dig_z1<15:8>										| конст	|	dig_z1<15:8>   - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_XYZ1_LSB	0x6C		//	Значения корректировки					|											dig_xyz1<7:0>										| конст	|	dig_xyz1<7:0>  - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_XYZ1_MSB	0x6D		//	Значения корректировки					|											dig_xyz1<15:8>										| конст	|	dig_xyz1<15:8> - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z3_LSB		0x6E		//	Значения корректировки					|											dig_z3<7:0>											| конст	|	dig_z3<7:0>    - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_Z3_MSB		0x6F		//	Значения корректировки					|											dig_z3<15:8>										| конст	|	dig_z3<15:8>   - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_XY2			0x70		//	Значения корректировки					|											dig_xy2<7:0>										| конст	|	dig_xy2<7:0>   - значение устанавливается на заводе изготовителе
#define REG_BMM_DIG_XY1			0x71		//	Значения корректировки					|											dig_xy1<7:0>										| конст	|	dig_xy1<7:0>   - значение устанавливается на заводе изготовителе

class iarduino_Position_BMX055_BMM: public iarduino_Position_BMX055_BASE{														//
	public:																														//
	/**	функции доступные пользователю **/																						//
//		Инициализация датчика:																									//
		bool	begin(bool setZero,float*ptrX,float*ptrY,float*ptrZ,float*ptrT,float*ptrQ1,float*ptrQ2,float*ptrQ3,float*ptrQ4){//	Аргументы: setZero - флаг указывающий о необходимости установить текущие показания в 0, указатели на переменные выводимых данных)
					axisX=ptrX;																									//	Присваиваем указателю axisX адрес из указателя ptrX который ссылается на переменную axisX класса iarduino_Position_BMX055 предназначенную для вывода данных по оси X
					axisY=ptrY;																									//	Присваиваем указателю axisY адрес из указателя ptrY который ссылается на переменную axisY класса iarduino_Position_BMX055 предназначенную для вывода данных по оси Y
					axisZ=ptrZ;																									//	Присваиваем указателю axisZ адрес из указателя ptrZ который ссылается на переменную axisZ класса iarduino_Position_BMX055 предназначенную для вывода данных по оси Z
					temp =ptrT;																									//	Присваиваем указателю temp  адрес из указателя ptrT который ссылается на переменную temp  класса iarduino_Position_BMX055 предназначенную для вывода температуры
					uint8_t i=0;																								//	Определяем переменную для подсчёта количества попыток выхода из режима приостановки (suspend) и сравнения ID чипа
					uint8_t j[2];																								//	Объявляем массив j размером 2 байта для чтения 16-битных корректировочных значений
					objI2C.begin(100);																							//	Инициируем работу по шине I2C на скорости 100 кГц
				//	Выходим из режима приостановки (suspend) и устанавливаем рабочие параметры									//	Чип сам входит в режим приостановки (suspend) сразу после подачи питания. Переход в активный режим (Normal) нормальный или (Forced) принудительный, возможен только из спящего (sleep) режима.
					while (	objI2C.readByte(BMM_ADDRES, REG_BMM_CHIPID) != BMM_ID){												//	Если содержимое регистра REG_BMM_CHIPID не совпало с реальным ID чипа указанным в константе BMM_ID, то ...
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_0, 0x82);													//	Выполняем программную перезагрузку установив оба бита softreset<1:0> регистра REG_BMM_CTRL_0
							delay(100);																							//	Ждём сброса значений регистров
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_0, 0x01);													//	Выходим из режима приостановки (suspend) в спящий (Sleep) режим, установив бит pwr_control регистра REG_BMM_CTRL_0
							delay(100);																							//	Ждём выхода из режима приостановки (suspend)
							i++; if(i>10){return false;}																		//	Возвращаем ошибку если более 10 попыток чтения и сравнения ID увенчались провалом
					}																											//
					setBandwidths(varBandwidth);																				//	Устанавливаем пропускную способность магнитометра с переходом из спящего (Sleep) режима в активный, нормальный (Normal) режим работы
					delay(100);																									//	Ждём установки нормального (Normal) режима работы
					setScale(BMM_REGULAR);																						//	Устанавливаем количество выборок магнитометра как в обычном предустановленном режиме BMM_REGULAR
				//	Читаем корректировочные значения																			//
					dig_x1 =objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_X1);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_X1
					dig_x2 =objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_X2);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_X2
					dig_y1 =objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_Y1);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_Y1
					dig_y2 =objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_Y2);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_Y2
					dig_xy1=objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_XY1);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_XY1
					dig_xy2=objI2C.readByte (BMM_ADDRES, REG_BMM_DIG_XY2);														//	Читаем один байт корректировочных значений из регистра  REG_BMM_DIG_XY2
							objI2C.readBytes(BMM_ADDRES, REG_BMM_DIG_Z1_LSB,   j, 2);	dig_z1   = ((uint16_t)j[1]<<8) | j[0];	//	Читаем два байта корректировочных значений из регистров REG_BMM_DIG_Z1_LSB и REG_BMM_DIG_Z1_MSB
							objI2C.readBytes(BMM_ADDRES, REG_BMM_DIG_Z2_LSB,   j, 2);	dig_z2   = (( int16_t)j[1]<<8) | j[0];	//	Читаем два байта корректировочных значений из регистров REG_BMM_DIG_Z2_LSB и REG_BMM_DIG_Z2_MSB
							objI2C.readBytes(BMM_ADDRES, REG_BMM_DIG_Z3_LSB,   j, 2);	dig_z3   = (( int16_t)j[1]<<8) | j[0];	//	Читаем два байта корректировочных значений из регистров REG_BMM_DIG_Z3_LSB и REG_BMM_DIG_Z3_MSB
							objI2C.readBytes(BMM_ADDRES, REG_BMM_DIG_Z4_LSB,   j, 2);	dig_z4   = (( int16_t)j[1]<<8) | j[0];	//	Читаем два байта корректировочных значений из регистров REG_BMM_DIG_Z4_LSB и REG_BMM_DIG_Z4_MSB
							objI2C.readBytes(BMM_ADDRES, REG_BMM_DIG_XYZ1_LSB, j, 2);	dig_xyz1 = ((uint16_t)j[1]<<8) | j[0];	//	Читаем два байта корректировочных значений из регистров REG_BMM_DIG_XYZ1_LSB и REG_BMM_DIG_XYZ1_MSB
					if(setZero){setFastOffset();}																				//	Выполняем быструю компенсацию смещения данных (значение всех осей сбросятся в ноль, если данные текущих угловых скоростей по осям были меньше ±125°/с)
					return true;																								//
		}																														//
																																//
//		Самотестирование датчика:																								//
		uint8_t	test(void){																										//	Аргумент: отсутствует
					uint8_t i, j;																								//	Объявляем переменные для хранения значений однобайтовых регистров
					float   k[2];																								//	Объявляем массив для хранения показаний по оси Z при подаче положительного и отрицательного тока на втроенную катушку индуктивности
				//	Обычное самотестирование (Normal Self Test):																//	Проверяется наличие соединения и КЗ тракта FlipCore с ASIC для осей X и Y. Проверяется наличие и скорость их обработки сигналов по всем осям, а уровни сигналов сравниваются с пороговыми значениями.
					if	  (	objI2C.readByte (BMM_ADDRES, REG_BMM_CHIPID) != BMM_ID){return BMM_ERR_ID;}							//	Возвращаем ошибку если содержимое регистра REG_BMM_CHIPID не совпало с реальным ID чипа указанным в константе BMM_ID
					i = 	objI2C.readByte (BMM_ADDRES, REG_BMM_CTRL_1);														//	Читаем значение регистра REG_BMM_CTRL_1 в переменную i
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i|0x07);												//	Выполняем обычное самотестирование в спящем режиме (сохраняем значение переменной i обратно в регистр REG_BMM_CTRL_1 предварительно установив биты op_mode<1:0> и self_test
					while (	objI2C.readByte (BMM_ADDRES, REG_BMM_CTRL_1) & 0x01){;}												//	Ждём сброса бита self_test регистра REG_BMM_CTRL_1
					if	  (!objI2C.readByte (BMM_ADDRES, REG_BMM_X_LSB ) & 0x01){return BMM_ERR_ST;}							//	Если флаг x_self_test регистра REG_BMM_X_LSB не установлен, значит в результате самотестирования выявлены ошибки для канала оси X
					if	  (!objI2C.readByte (BMM_ADDRES, REG_BMM_Y_LSB ) & 0x01){return BMM_ERR_ST;}							//	Если флаг y_self_test регистра REG_BMM_Y_LSB не установлен, значит в результате самотестирования выявлены ошибки для канала оси Y
					if	  (!objI2C.readByte (BMM_ADDRES, REG_BMM_Z_LSB ) & 0x01){return BMM_ERR_ST;}							//	Если флаг z_self_test регистра REG_BMM_Z_LSB не установлен, значит в результате самотестирования выявлены ошибки для канала оси Z
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i);													//	Возврашаем исходные значения регистру REG_BMM_CTRL_1
				//	Расширенное самотестирование (Advanced Self Test):															//	Проверяются значения по оси Z на которую будет действовать магнитное поле создаваемое током проходящим через встроенную катушку индуктивности. Ток проходящий через катушку создаёт индукцию магнитного поля в ±100 мкТл (знак зависит от направления тока), значит разница двух показаний должна составлять около 200 мкТл.
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i|0x06);												//	Переходим в спящий режим (сохраняем значение переменной i обратно в регистр REG_BMM_CTRL_1 предварительно установив биты op_mode<1:0>
					j = 	objI2C.readByte (BMM_ADDRES, REG_BMM_INT_EN_1);														//	Читаем значение регистра REG_BMM_INT_EN_1 в переменную j
							objI2C.writeByte(BMM_ADDRES, REG_BMM_INT_EN_1, j|0x18);												//	Отключаем каналы осей X и Y (сохраняем значение переменной j обратно в регистр REG_BMM_INT_EN_1 предварительно установив биты channel_y и channel_x (0-включает канал, 1-отключает канал))
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i&0x39|0xC2);											//	Выполняем принудительное чтение данных с подачей положительного тока на катушку индуктивности (сохраняем значение переменной i обратно в регистр REG_BMM_CTRL_1 предварительно записав значения «11» в биты advanced_self_test<1:0> и «01» в биты op_mode<1:0>)
					while ((objI2C.readByte (BMM_ADDRES, REG_BMM_CTRL_1) & 0x06) != 0x06){;}									//	Ждём входа в спящий режим (будут установлены биты op_mode<1:0>), модуль сам переходит в спящий режим после выполнения одного считывания в принудительном режиме
							readADC(); k[0] = (float) mag_adc[2] * varQuantum;													//	Читаем показания АЦП магнитоматра в массив mag_adc. Преобразуем показание оси Z в мГс и сохраняем его в 0 ячейке массива k
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i&0x39|0x82);											//	Выполняем принудительное чтение данных с подачей отрицательного тока на катушку индуктивности (сохраняем значение переменной i обратно в регистр REG_BMM_CTRL_1 предварительно записав значения «10» в биты advanced_self_test<1:0> и «01» в биты op_mode<1:0>)
					while ((objI2C.readByte (BMM_ADDRES, REG_BMM_CTRL_1) & 0x06) != 0x06){;}									//	Ждём входа в спящий режим (будут установлены биты op_mode<1:0>), модуль сам переходит в спящий режим после выполнения одного считывания в принудительном режиме
							readADC(); k[1] = (float) mag_adc[2] * varQuantum;													//	Читаем показания АЦП магнитоматра в массив mag_adc. Преобразуем показание оси Z в мГс и сохраняем его в 1 ячейке массива k
							objI2C.writeByte(BMM_ADDRES, REG_BMM_INT_EN_1, j);													//	Возврашаем исходные значения регистру REG_BMM_INT_EN_1 из переменной j
							objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, i);													//	Возврашаем исходные значения регистру REG_BMM_CTRL_1 из переменной i
                    if	  ((k[0]-k[1]) > 2100.0f){return BMM_ERR_ST;}															//	Если разница между двумя значениями по оси Z больше 210 мкТл (2100 мГс) значит тест провалился. Встроенная катушка создаёт магнитную индукцию в 100 мкТл при прямом токе и -100 мкТл при обратном токе, значит разница в показаниях должна составлять 200 мкТл (2000 мГс)
                    if	  ((k[0]-k[1]) < 1900.0f){return BMM_ERR_ST;}															//	Если разница между двумя значениями по оси Z меньше 190 мкТл (1900 мГс) значит тест провалился. Встроенная катушка создаёт магнитную индукцию в 100 мкТл при прямом токе и -100 мкТл при обратном токе, значит разница в показаниях должна составлять 200 мкТл (2000 мГс)
					return 0;																									//	Выводим результат успешного самотестирования
		}																														//
																																//
//		Чтение данных из датчика:																								//
		bool	read(uint8_t thisMera){																							//	Аргумент: мера измерения читаемых данных (BMM_MG / BMM_MCT)
					if(!readADC()){return false;}																				//	Читаем показания АЦП магнитоматра в массив mag_adc
					float j = 1;																								//	Определяем множитель
					switch(thisMera){																							//	В зависимости от установленной меры измерений
						default:	BMM_MG;																						//	По умолчанию значения возвращаются в мГс
						case		BMM_MG:		j=1.0f;			break;															//	Если данные требуется возвращать в мГс
						case		BMM_MCT:	j=0.1f;			break;															//	Если данные требуется возвращать в мкТл
					}																											//	Результирующее значение получается из скорректированных данных АЦП (mag_adc) умноженных на шаг квантования (varQuantum) с вычетом вычисленного смещения (magBias) и преобразованного в требуемую величину измерений
																																//
					*axisX = -(((float) mag_adc[1] * varQuantum - magBias[1]) * j);												//  Получаем значение для оси X            | Ось Z                  На картинке изображены:
					*axisY =   ((float) mag_adc[0] * varQuantum - magBias[0]) * j ;												//  Получаем значение для оси Y            |                        Ось X, Ось Y, Ось Z - оси модуля
					*axisZ =   ((float) mag_adc[2] * varQuantum - magBias[2]) * j ;												//  Получаем значение для оси Z            |       / Ось X          AX, AY, AZ          - оси акселерометра
					*temp  =    (float) mag_adc[3] * 273.15 / 10000;															//  Получаем значение температуры          |AZ    /                 GX, GY, GZ          - оси гироскопа
					return true;																								//                                         |GZ   / AX               MX, MY, MZ          - оси магнитометра
		}		//	значение для оси X находится в ячейках 0 массивов mag_adc и magBias											//                                         |MZ  / GX                
				//	значение для оси Y находится в ячейках 1 массивов mag_adc и magBias											//                                         |   /-MY                 Ось X магнитометра находится на оси Y модуля
				//	значение для оси Z находится в ячейках 2 массивов mag_adc и magBias											//                                         |  /                     Ось Y магнитометра направлена в обратную сторону относительно оси X модуля
				//	значение для температуры находится в 3 ячейке массива mag_adc												//                   AY         *----------|-/------------*         Ось Z магнитометра совпадает с осью Z модуля
				//	Но так как у магнитометра только ось Z совпадает с акселерометром и гироскопом								//   _______________GY_________/___________|/            /|         Если на картинке повернуть магнитометр на 90° по часовой стрелке, то
				//	а по осям XY магнитометр сдвинут на 90° против часовой стрелке, то ...										//   Ось Y         MX         /                         / *         Оси магнитометра совпадут с осями остальных датчиков и модуля
				//	По указателю axisX мы передаём значение оси -Y магнитометра													//                           *-------------------------* /          Оси героскопа направлены не вдоль осей модуля,
				//	По указателю axisY мы передаём значение оси  X магнитометра													//                           |                         |/           а вращаются по часовой стрелке в направлении этих осей,
				//	По указателю axisZ мы передаём значение оси  Z магнитометра													//                           *-------------------------*            так как это нарисовано на плате Trema-модуля IMU - 9 DOF
																																//
//		Установка количества выборок магнитометра:																				//
		void	setScale(uint8_t scale){																						//	Аргумент: предустановленный режим
					uint8_t rep_xy, rep_z, data_rate;																			//	Объявляем переменные для хранения количества выборок по осям XY, Z и требуемой для них полосы пропускания.
					switch (scale){																								//	Проверяем значение аргумента функции (1 из 4 возможных предустановленных режимов работы магнитометра)
						default:		  	scale=BMM_REGULAR;																	//	Если значение некорректное, то меняем его на BMM_REGULAR (обычный предустановленный режим)
						case BMM_LOW_PWR:	rep_xy=3;				rep_z=3;		data_rate=BMM_10Hz; break;					//	Экономичный прдустановленный режим      -  3 выборки для осей XY,  3 выборки для оси Z, рекомендуемая полоса пропускания 10 Гц, шумы по осям X/Y/Z = 1.0/1.0/1.4 мкТл, среднее потребление тока 0.17 мА.
						case BMM_REGULAR:	rep_xy=9;				rep_z=15;		data_rate=BMM_10Hz; break;					//	Обычный прдустановленный режим          -  9 выборок для осей XY, 15 выборок для оси Z, рекомендуемая полоса пропускания 10 Гц, шумы по осям X/Y/Z = 0.6/0.6/0.6 мкТл, среднее потребление тока 0.50 мА.
						case BMM_ENHANCED:	rep_xy=15;				rep_z=27;		data_rate=BMM_10Hz; break;					//	Улучшенный прдустановленный режим       - 15 выборок для осей XY, 27 выборок для оси Z, рекомендуемая полоса пропускания 10 Гц, шумы по осям X/Y/Z = 0.5/0.5/0.5 мкТл, среднее потребление тока 0.80 мА.
						case BMM_HIGH:		rep_xy=47;				rep_z=83;		data_rate=BMM_20Hz; break;					//	Прдустановленный режим высокой точности - 47 выборок для осей XY, 83 выборки для оси Z, рекомендуемая полоса пропускания 20 Гц, шумы по осям X/Y/Z = 0.3/0.3/0.3 мкТл, среднее потребление тока 4.90 мА.
					}						rep_xy=(rep_xy-1)/2;	rep_z=rep_z-1;												//	Количество выборок XY=1+2*rep_xy => rep_xy=(количество выборокXY-1)/2. Количество выборок Z=1+rep_z => rep_x=количество выборокZ-1.
					setBandwidths(data_rate); 																					//	Устанавливаем пропускную способность магнитометра с переходом в нормальный режим работы
					objI2C.writeByte(BMM_ADDRES, REG_BMM_REP_XY, rep_xy);														//	Устанавливаем количество выборок по осям XY
					objI2C.writeByte(BMM_ADDRES, REG_BMM_REP_Z , rep_z );														//	Устанавливаем количество выборок по оси Z
		}																														//
																																//
//		Установка полосы пропускания для фильтрованных данных:																	//
		void	setBandwidths(uint8_t bandwidths){																				//	Аргумент: полоса пропускания
					if(bandwidths>BMM_30Hz){bandwidths=BMM_30Hz;}																//	Проверяем корректность аргумента
					varBandwidth=bandwidths;																					//	Запоминаем выбранную полосу пропускания
					objI2C.writeByte(BMM_ADDRES, REG_BMM_CTRL_1, varBandwidth<<5);												//	Устанавливаем пропускную способность гироскопа (биты data_rate регистра REG_BMM_CTRL_1)
		}																														//
																																//
//		Выполнение компенсайии смещения данных:																					//	Усреднённые значения на момент выполнения компенсации заносятся в массив magBias и потом будут вычитаться из реальных показаний
		void	setFastOffset(void){																							//	Аргумент: отсутствует
				int16_t mag_max [3] = {-32768,-32768,-32768};																	//	Определяем массив для хранения максимальных показаний АЦП по осям XYZ
				int16_t mag_min [3] = { 32767, 32767, 32767};																	//	Определяем массив для хранения минимальных  показаний АЦП по осям XYZ
				for(uint8_t i=0; i<128; i++){	readADC();																		//	Выполняем цикл чтения показания АЦП магнитоматра в массив mag_adc в течении 128 раз
				for(uint8_t j=0; j<3; j++){																						//	Проходим по данным трёх осей (X/Y/Z)
					if(mag_adc[j]>mag_max[j]){mag_max[j]=mag_adc[j];}															//	Если прочитанные данные оси являются максимальными за всё время выполнения этого цикла, то сохраняем их в массив mag_max
					if(mag_adc[j]<mag_min[j]){mag_min[j]=mag_adc[j];}															//	Если прочитанные данные оси являются минимальными  за всё время выполнения этого цикла, то сохраняем их в массив mag_min
				}	delay(getPeriodBandwidths());																				//	Устанавливаем задержку достаточную для готовности новых данных в соответствии с выбранной полосой пропускания
				}																												//
				magBias[0] = float((int32_t)(mag_max[0]+mag_min[0])/2) * varQuantum;											//	среднее значение показаний АЦП по оси X умножаем на шаг квантования varQuantum и получаем смещение показаний оси в мГс
				magBias[1] = float((int32_t)(mag_max[1]+mag_min[1])/2) * varQuantum;											//	среднее значение показаний АЦП по оси Y умножаем на шаг квантования varQuantum и получаем смещение показаний оси в мГс
				magBias[2] = float((int32_t)(mag_max[2]+mag_min[2])/2) * varQuantum;											//	среднее значение показаний АЦП по оси Z умножаем на шаг квантования varQuantum и получаем смещение показаний оси в мГс
		}																														//
																																//
	private:																													//
//		Переменные:																												//
		int8_t		dig_x1;																										//	Объявляем переменную для хранеия корректировочного значения
		int8_t		dig_y1;																										//	Объявляем переменную для хранеия корректировочного значения
		int8_t		dig_x2;																										//	Объявляем переменную для хранеия корректировочного значения
		int8_t		dig_y2;																										//	Объявляем переменную для хранеия корректировочного значения
		uint16_t	dig_z1;																										//	Объявляем переменную для хранеия корректировочного значения
		int16_t		dig_z2;																										//	Объявляем переменную для хранеия корректировочного значения
		int16_t		dig_z3;																										//	Объявляем переменную для хранеия корректировочного значения
		int16_t		dig_z4;																										//	Объявляем переменную для хранеия корректировочного значения
		uint8_t		dig_xy1;																									//	Объявляем переменную для хранеия корректировочного значения
		int8_t		dig_xy2;																									//	Объявляем переменную для хранеия корректировочного значения
		uint16_t	dig_xyz1;																									//	Объявляем переменную для хранеия корректировочного значения
		int16_t		mag_adc[4]={0,0,0,0};																						//	Определяем массив для хранения прочитанных показаний АЦП по осям XYZ и температуры
		float		magBias[3]={0,0,0};																							//	Определяем массив для хранения смещения показаний магнитометра в мГс для осей XYZ на момент выполнения компенсайии смещения данных
																																//
//		Чтение показаний АЦП магнитометра с корректировкой прочитанных значений:												//
		bool	readADC(void){																									//	Аргумент: отсутствует
					uint8_t i[8]; if(!objI2C.readBytes(BMM_ADDRES, REG_BMM_X_LSB, i, 8)){return false;}							//	Читаем 8 байт регистров АЦП начиная с регистра REG_BMM_X_LSB в объявленный массив i
					uint16_t j = ((uint16_t(i[7])<<8) | i[6]) >> 2;																//	Получаем сопростивление по которому будет рассчитана температура
					if(i[6] & 0x01 == 0){return false;}																			//	Если не установлен бит data_ready регистра REG_BMM_TEMP_LSB, значит данные не новые
			/* T */	mag_adc[3] = int16_t(uint16_t((int32_t(dig_xyz1)<<14)/(j != 0 ? j : dig_xyz1))-uint16_t(0x4000));			//	Рассчитываем температуру по полученному сопротивлению
			/* X */ mag_adc[0] = int16_t((int32_t (((int16_t(i[1])<<8)|i[0])>>3)*((((((int32_t(dig_xy2)*((int32_t(mag_adc[3])*int32_t(mag_adc[3]))>>7))+(int32_t(mag_adc[3])*int32_t(int16_t(dig_xy1)<<7)))>>9)+int32_t(0x100000))*int32_t(int16_t(dig_x2)+int16_t(0xA0)))>>12))>>13)+(int16_t(dig_x1)<<3);	// Получаем значение АЦП для оси X и корректируем его
			/* Y */ mag_adc[1] = int16_t((int32_t (((int16_t(i[3])<<8)|i[2])>>3)*((((((int32_t(dig_xy2)*((int32_t(mag_adc[3])*int32_t(mag_adc[3]))>>7))+(int32_t(mag_adc[3])*int32_t(int16_t(dig_xy1)<<7)))>>9)+int32_t(0x100000))*int32_t(int16_t(dig_y2)+int16_t(0xA0)))>>12))>>13)+(int16_t(dig_y1)<<3);	// Получаем значение АЦП для оси Y и корректируем его
			/* Z */ mag_adc[2] =        ((int32_t((((int16_t(i[5])<<8)|i[4])>>1)-dig_z4)<<15)-((int32_t(dig_z3)*int32_t(int16_t(j)-int16_t(dig_xyz1)))>>2))/(dig_z2+int16_t(((int32_t(dig_z1)*(int16_t(j)<<1))+(1<<15))>>16));																				// Получаем значение АЦП для оси Z и корректируем его
					return true;																								//
		}																														//
																																//
//		Получение минимального периода чтения данных для выбранной полосы пропускания:											//
		uint32_t	getPeriodBandwidths(void){																					//	Аргумент: отсутствует
					switch (varBandwidth){																						//	Проверяем значение полосы пропускания
						default:		varBandwidth=BMM_10Hz;																	//	Если значение некорректное, то меняем его на BMM_10Hz (полоса пропускания 10 Гц)
						case BMM_2Hz :	return 525; break;																		//	Период опроса данных для полосы пропускания  2 Гц составляет 500 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_6Hz :	return 175; break;																		//	Период опроса данных для полосы пропускания  6 Гц составляет 167 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_8Hz :	return 130; break;																		//	Период опроса данных для полосы пропускания  8 Гц составляет 125 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_10Hz:	return 105; break;																		//	Период опроса данных для полосы пропускания 10 Гц составляет 100 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_15Hz:	return  70; break;																		//	Период опроса данных для полосы пропускания 15 Гц составляет  67 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_20Hz:	return  53; break;																		//	Период опроса данных для полосы пропускания 20 Гц составляет  50 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_25Hz:	return  42; break;																		//	Период опроса данных для полосы пропускания 25 Гц составляет  40 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
						case BMM_30Hz:	return  35; break;																		//	Период опроса данных для полосы пропускания 30 Гц составляет  33 мс	(добавляем 5% чтоб к этому времени данные точно были готовы)
					}																											//
		}																														//
																																//
//		Запрос используемого фильтра:																							//
		uint8_t	getFilter(void){return 0;}																						//	Фильтр используется только для объекта BMX, но функцию объявить нужно, так как данный класс является производным и должен содержать все функции полиморфного класса
																																//
	private:																													//
	/**	Внутренние переменные **/																								//
		iarduino_I2C objI2C;																									//	Создаём объект для работы с шиной I2C
//		uint8_t	varRanges =		±256 мкТл для осей XY / ±1024 мкТл для оси Z			(1 мкТл = 10 мГс)						//	Определяем переменную для хранения полного диапазона измерений (какой индукции магнитного поля соответствует значение где все биты установлены в «1»)
		uint8_t	varBandwidth =	BMM_10Hz;																						//	Определяем переменную для хранения полосы пропускания фильтрованных данных
		float	varQuantum =	1.0/1.6;	/***  1.0/1.6 мГс  = 1.0/16.0 мкТл  ***/											//	Определяем переменную для хранения шага квантования (какой индукции магнитного поля мГс равно значение «1» из регистра данных)
		float *	axisX;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси X
		float *	axisY;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси Y
		float *	axisZ;																											//	Объявляем указатель который будет ссылаться на переменную для вывода данных по оси Z
		float *	temp;																											//	Объявляем указатель который будет ссылаться на переменную для вывода температуры
};																																//
																																//
#endif																															//